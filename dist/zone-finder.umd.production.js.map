{"version":3,"file":"zone-finder.umd.production.js","sources":["../src/get-zones-in-grid.ts","../src/neighbours.ts"],"sourcesContent":["import { Coords, Grid, Zone } from 'core';\nimport { getOthogonalNeighbours } from './neighbours';\n\nexport function getZonesInGrid<T>(\n  grid: Grid<T>,\n  getNeighbours: (\n    coords: Coords\n  ) => ReadonlyArray<Coords> = getOthogonalNeighbours\n): ReadonlyArray<Zone<T>> {\n  //\n  const gridHeight = grid.length;\n  const gridWidth = grid[0].length;\n\n  const getCellType = ([y, x]: Coords) => grid[y][x];\n\n  const isInGrid = ([y, x]: Coords) => {\n    return y >= 0 && x >= 0 && y < gridHeight && x < gridWidth;\n  };\n\n  const zones: Zone<T>[] = [];\n  const addZone = (type: T) => {\n    const zone = { type, cells: [] };\n    zones.push(zone);\n    return zone;\n  };\n\n  const visited: Coords[] = [];\n  const wasVisited = ([y, x]: Coords) => {\n    return visited.some(([vy, vx]) => vy === y && vx === x);\n  };\n\n  const visitCoords = (coords: Coords, zone: Zone<T> | null) => {\n    //\n    visited.push(coords);\n    const type = getCellType(coords);\n\n    zone = zone || addZone(type);\n    zone.cells.push(coords);\n\n    const isMatchingNeighbour = (coords: Coords) =>\n      getCellType(coords) === type;\n\n    const matchingNeighbours = getNeighbours(coords)\n      .filter(isInGrid)\n      .filter(isMatchingNeighbour);\n\n    matchingNeighbours.forEach(nCoords => {\n      if (!wasVisited(nCoords)) {\n        visitCoords(nCoords, zone);\n      }\n    });\n  };\n\n  getAllCoordinates(grid).forEach(coords => {\n    if (!wasVisited(coords)) {\n      visitCoords(coords, null);\n    }\n  });\n\n  return zones;\n}\n\nfunction getAllCoordinates<T>(grid: Grid<T>): ReadonlyArray<Coords> {\n  return grid.reduce( (acc, row, y ) => {\n    return [...acc, ...(row.map((_, x) => {\n      return [y, x] as Coords;\n    })) ]\n  }, [] as Coords[])\n}","import { Coords } from 'core';\n\nexport function getOthogonalNeighbours([y, x]: Coords): ReadonlyArray<Coords> {\n  return [[y - 1, x], [y + 1, x], [y, x - 1], [y, x + 1]];\n}\n\nexport function getDiagonalNeighbours([y, x]: Coords): ReadonlyArray<Coords> {\n  return [[y - 1, x - 1], [y + 1, x + 1], [y + 1, x - 1], [y - 1, x + 1]];\n}\n\nexport function getAllNeighbours([y, x]: Coords): ReadonlyArray<Coords> {\n  return getOthogonalNeighbours([y, x]).concat(getDiagonalNeighbours([y, x]));\n}"],"names":["grid","getNeighbours","y","x","gridHeight","length","gridWidth","getCellType","isInGrid","zones","visited","wasVisited","some","vy","vx","visitCoords","coords","zone","push","type","cells","addZone","matchingNeighbours","filter","forEach","nCoords","reduce","acc","row","map","_","getAllCoordinates"],"mappings":"uOAIEA,EACAC,YCHsCC,EAAGC,UAClC,CAAC,CAACD,EAAI,EAAGC,GAAI,CAACD,EAAI,EAAGC,GAAI,CAACD,EAAGC,EAAI,GAAI,CAACD,EAAGC,EAAI,YDO9CC,EAAaJ,EAAKK,OAClBC,EAAYN,EAAK,GAAGK,OAEpBE,EAAc,EAAEL,EAAGC,KAAeH,EAAKE,GAAGC,GAE1CK,EAAW,EAAEN,EAAGC,KACbD,GAAK,GAAKC,GAAK,GAAKD,EAAIE,GAAcD,EAAIG,EAG7CG,EAAmB,GAOnBC,EAAoB,GACpBC,EAAa,EAAET,EAAGC,KACfO,EAAQE,KAAK,EAAEC,EAAIC,KAAQD,IAAOX,GAAKY,IAAOX,GAGjDY,EAAc,CAACC,EAAgBC,KAEnCP,EAAQQ,KAAKF,SACPG,EAAOZ,EAAYS,GAEzBC,EAAOA,GAhBQE,CAAAA,UACTF,EAAO,CAAEE,KAAAA,EAAMC,MAAO,WAC5BX,EAAMS,KAAKD,GACJA,GAaQI,CAAQF,GACvBF,EAAKG,MAAMF,KAAKF,SAKVM,EAAqBrB,EAAce,GACtCO,OAAOf,GACPe,OAL0BP,GAC3BT,EAAYS,KAAYG,GAM1BG,EAAmBE,QAAQC,IACpBd,EAAWc,IACdV,EAAYU,EAASR,aAc7B,SAA8BjB,UACrBA,EAAK0B,OAAQ,CAACC,EAAKC,EAAK1B,IACtB,IAAIyB,KAASC,EAAIC,IAAI,CAACC,EAAG3B,IACvB,CAACD,EAAGC,KAEZ,IAdH4B,CAAkB/B,GAAMwB,QAAQR,IACzBL,EAAWK,IACdD,EAAYC,EAAQ,QAIjBP"}